var exec = require('child_process').exec
var fs = require('fs')
var path = require('path')
var mkdirp = require('mkdirp')
var tmp = require('tmp')

var cleanups = [];

function divisable(val) {
	return Math.round(val / 2) * 2
}
//start and duration given in seconds!
function clip(input, output, start, duration, options) {
	return new Promise((resolve, reject) => {
		var w, h;

		if (typeof (options) === 'undefined') {
			w = h = false
		} else {
			w = typeof (options.width) !== 'undefined'
			h = typeof (options.height) !== 'undefined'
		}

		var d = {}
		var cmd = `ffmpeg -y -i ${input} -ss ${timecode(start)} -t ${timecode(duration)} -r 10 -vf "scale=`

		if (w && h) {
			d.w = options.width
			d.h = options.height
		} else if (w) {
			d.w = options.width
			d.h = "trunc(in_h/2)*2"
		} else if (h) {
			d.w = "trunc(in_w/2)*2"
			d.h = options.height
		} else {
			d.w = 300
			d.h = "trunc(in_h/2)*2"
		}
		cmd += `${d.w}:${d.h}" -an ${output}`

		exec(cmd, (err, stdout, stderr) => {
			if (err) {
				console.log('Error occurred, run this command to debug: ' + cmd)
			}
		}).on('exit', () => {
			resolve()
		})
	})
}

module.exports = function (input, output, options) {
	/*
	input: path,
	output: path,
	options: {
		width: number,
		height: number
	}
	*/
	return new Promise((resolve, reject) => {
		if (typeof (input) !== 'string' || typeof (output) !== 'string') {
			reject('Input/Output should be formatted strings')
		}
		//if input doesn't exist, reject
		fs.access(input, (err) => {
			if (err) reject('Input file doesn\'t exist')
		})

		//make sure the path to output exists
		var dir = path.dirname(output)
		fs.access(dir, (err) => {
			if (err) mkdirp.sync(dir)
		})

		exec(`ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 ${input}`, (err, stdout, stderr) => {

			var seconds = stdout;
			//take one clip from the start, one from the middle and one in the end.

			var p = Math.round(seconds / 3)
			var timecodes = [
				getRandomInt(0, p),
				getRandomInt(p, p * 2),
				getRandomInt(p * 2, seconds)
			]

			//holds the temporary paths generated by tmp
			var paths = [];

			function cb(i) {
				if (i < 3) {
					tmp.file({
						prefix: 'video-thumbnail-part',
						postfix: '.mp4',
						discardDescriptor: true,
						keep: true
					}, (err, path, fd, cleanup) => {
						paths.push(path)
						cleanups.push(cleanup)

						clip(input, path, timecodes[i], 5, options).then(() => {
							cb(i + 1)
						})
					})
				} else {
					//concat the files into a tmp file
					var f = tmp.file({
						prefix: 'video-thumbnail-list',
						postfix: '.txt',
					}, (err, path, fd, cleanup) => {
						var data = paths.map((e) => { return `file '${e}'` }).join('\n');
						//write to it
						fs.writeFileSync(fd, data)
						var cmd = `ffmpeg -y -safe 0 -f concat -i ${path} -codec copy ${output}`
						exec(cmd, (err, stdout, stderr) => {
							if(err)
								console.log('Error occurred, run this command to debug: ' + cmd)
							cleanups.forEach((e) => {
								e();
							})
							cleanup();

							resolve()
						})

					})
				}
			}
			//make 5 seconds three times, to temporary files
			cb(0)
		})
	})
}

function getRandomInt(min, max) {
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

function timecode(sec_num) {
	var hours = Math.floor(sec_num / 3600);
	var minutes = Math.floor((sec_num - (hours * 3600)) / 60);
	var seconds = sec_num - (hours * 3600) - (minutes * 60);

	if (hours < 10) {
		hours = "0" + hours;
	}
	if (minutes < 10) {
		minutes = "0" + minutes;
	}
	if (seconds < 10) {
		seconds = "0" + seconds;
	}
	return hours + ':' + minutes + ':' + seconds;
	//from https://stackoverflow.com/questions/6312993/javascript-seconds-to-time-string-with-format-hhmmss
}